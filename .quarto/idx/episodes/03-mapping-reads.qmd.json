{"title":"From fastq files to alignments","markdown":{"yaml":{"title":"From fastq files to alignments","engine":"knitr","format":{"html":{"fig-width":5,"fig-height":4,"code-annotations":"hover"}}},"headingText":"Quality control: `fastqc`","containsRefs":false,"markdown":"\n\nThe moment is there: you received the FASTQ files from your sequencing provider! Now what?\n\n\nThe first step in the RNA-seq workflow is to assess the quality of the sequencing reads. Sequence reads generated from next-generation sequencing technologies come in the FASTQ file format. This file format evolved from FASTA: it contains sequence data, but also contains quality information. For a single record (sequence read) there are four lines, each of which are described below:\n\n|Line|Description|\n|----|-----------|\n|1|Always begins with '@' and then information about the read|\n|2|The actual DNA sequence|\n|3|Always begins with a '+' and sometimes the same info in line 1|\n|4|Has a string of characters which represent the quality scores; must have same number of characters as line 2|\n\nLet's run `fastqc` on one sample:\n\n```{bash filename=\"bash\"}\n#| eval: false\nfastqc -o /workspace/fastqc /datasets/Arabidopsis_sample1.fq.gz\n```\n\nDoing this manually for every sample would be quite tiring, especially when we would have many samples. Let's write a `bash` for loop to take care of this for us:\n\n```{bash filename=\"bash\"}\n#| eval: false\nfor filename in  /datasets/*.fq.gz # <1>\n  do\n    fastqc -o fastqc $filename # <2>\n  done\n```\n\n1. Here we define a variable `filename` that will subsequently get the values of all datasets matching the `/datasets/*.fq.gz` statement, where `*` acts as a wildcard.\n2. Here we add the actual command, where `$filename` will subsequently be filled in with all of our four filenames.\n\n## Trimming: `trimmomatic`\n\nOften, `fastqc` reports will reveal that sequencing adapters are still present in your reads. This is known as 'adapter contamination', and the presence of these sequences in the reads might affect how the reads map to the genome of interest. So, we need to get rid of them. We will `trimmomatic` to do this. \n\n```{bash filename=\"bash\"}\n#| eval: false\n# add trimmomatic command here\n```\n\n::: {.callout-tip title=\"Exercise\" icon=\"false\"}\nAfter running `trimmomatic`, the adapter contamination should be gone.\n\n1. How could you check whether `trimmomatic` indeed did it's job?\n2. Write a command to check this.\n:::\n\n::: {.callout-caution title=\"Solution\" collapse=\"true\" icon=\"false\"}\n1. We can run `fastqc` again, this time on the trimmed reads.\n2. \n```{bash filename=\"bash\"}\n#| eval: false\nfastqc -o /workspace/fastqc /datasets/Arabidopsis_sample1.trimmed.fq.gz\n```\n:::\n\n## Mapping: `STAR`\n\nOur reads are now ready for mapping. Mapping reads means figuring out where each read from the RNA-seq experiment originally came from within the genome. For RNA-seq experiments, it's important to pick a **splice-aware** aligner, since a RNA-seq read can span an exon-intron-exon boundary **(TODO: add a figure here to demonstrate this)**.\n\n::: {.callout-tip title=\"Question\" icon=\"false\"}\nSo, for RNA-seq we need splice-aware aligners. Can you come up with an experiment that would not require a splice-aware aligner program?\n:::\n\n::: {.callout-caution title=\"Solution\" collapse=\"true\" icon=\"false\"}\nIn experiments where we don't need to think about exon-intron boundaries. This is the case when the reads originate from genomic DNA, for example for whole genome sequencing experiments, or enrichment sequencing experiments like Chip-Seq. \n:::\n\nTo use an aligner, we must first get the **reference genome** and then *index* the reference genome. Indexing the genome prepares the genome in a way that allows a computer to search it efficiently. The genome, a multi-million basepair long string of text, is encoded into a different, computer-friendly datastructure such as a suffix tree. The details of this procedure are beyond the scope of this workshop, but it's important to do it!\n\nHere, we download the *Arabidopsis thaliana* reference genome and index it:\n\n```{bash filename=\"bash\"}\n#| eval: false\n# Index command here\n```\n\nAllright, let's finally run `STAR`: \n\n```{bash filename=\"bash\"}\n#| eval: false\n# run STAR here\n```\n\n### BAM and SAM files\n\n*TODO: explain BAM and SAM files here*\n\n### Inspecting the mapping on a genome browser\n\n## Counting: `featureCounts`\n\n## A note on the specific tools used here\n\nAs in many things in programming: there are many ways to reach the same goal. Here we have selected mapping, trimming and counting tools that we have available and have experience with, but there are many others that perform just as well. The following table highlights a few popular alternative options:\n\n| Task | Tool used here | Alternative tools |\n| ---- | -------------- | ----------------- |\n| Trimming | `Trimmomatic` | `cutadapt`, `fastp` |\n| Mapping | `STAR` | `HISAT2` |\n| Counting | `featureCounts` | `StringTie` |","srcMarkdownNoYaml":"\n\nThe moment is there: you received the FASTQ files from your sequencing provider! Now what?\n\n## Quality control: `fastqc`\n\nThe first step in the RNA-seq workflow is to assess the quality of the sequencing reads. Sequence reads generated from next-generation sequencing technologies come in the FASTQ file format. This file format evolved from FASTA: it contains sequence data, but also contains quality information. For a single record (sequence read) there are four lines, each of which are described below:\n\n|Line|Description|\n|----|-----------|\n|1|Always begins with '@' and then information about the read|\n|2|The actual DNA sequence|\n|3|Always begins with a '+' and sometimes the same info in line 1|\n|4|Has a string of characters which represent the quality scores; must have same number of characters as line 2|\n\nLet's run `fastqc` on one sample:\n\n```{bash filename=\"bash\"}\n#| eval: false\nfastqc -o /workspace/fastqc /datasets/Arabidopsis_sample1.fq.gz\n```\n\nDoing this manually for every sample would be quite tiring, especially when we would have many samples. Let's write a `bash` for loop to take care of this for us:\n\n```{bash filename=\"bash\"}\n#| eval: false\nfor filename in  /datasets/*.fq.gz # <1>\n  do\n    fastqc -o fastqc $filename # <2>\n  done\n```\n\n1. Here we define a variable `filename` that will subsequently get the values of all datasets matching the `/datasets/*.fq.gz` statement, where `*` acts as a wildcard.\n2. Here we add the actual command, where `$filename` will subsequently be filled in with all of our four filenames.\n\n## Trimming: `trimmomatic`\n\nOften, `fastqc` reports will reveal that sequencing adapters are still present in your reads. This is known as 'adapter contamination', and the presence of these sequences in the reads might affect how the reads map to the genome of interest. So, we need to get rid of them. We will `trimmomatic` to do this. \n\n```{bash filename=\"bash\"}\n#| eval: false\n# add trimmomatic command here\n```\n\n::: {.callout-tip title=\"Exercise\" icon=\"false\"}\nAfter running `trimmomatic`, the adapter contamination should be gone.\n\n1. How could you check whether `trimmomatic` indeed did it's job?\n2. Write a command to check this.\n:::\n\n::: {.callout-caution title=\"Solution\" collapse=\"true\" icon=\"false\"}\n1. We can run `fastqc` again, this time on the trimmed reads.\n2. \n```{bash filename=\"bash\"}\n#| eval: false\nfastqc -o /workspace/fastqc /datasets/Arabidopsis_sample1.trimmed.fq.gz\n```\n:::\n\n## Mapping: `STAR`\n\nOur reads are now ready for mapping. Mapping reads means figuring out where each read from the RNA-seq experiment originally came from within the genome. For RNA-seq experiments, it's important to pick a **splice-aware** aligner, since a RNA-seq read can span an exon-intron-exon boundary **(TODO: add a figure here to demonstrate this)**.\n\n::: {.callout-tip title=\"Question\" icon=\"false\"}\nSo, for RNA-seq we need splice-aware aligners. Can you come up with an experiment that would not require a splice-aware aligner program?\n:::\n\n::: {.callout-caution title=\"Solution\" collapse=\"true\" icon=\"false\"}\nIn experiments where we don't need to think about exon-intron boundaries. This is the case when the reads originate from genomic DNA, for example for whole genome sequencing experiments, or enrichment sequencing experiments like Chip-Seq. \n:::\n\nTo use an aligner, we must first get the **reference genome** and then *index* the reference genome. Indexing the genome prepares the genome in a way that allows a computer to search it efficiently. The genome, a multi-million basepair long string of text, is encoded into a different, computer-friendly datastructure such as a suffix tree. The details of this procedure are beyond the scope of this workshop, but it's important to do it!\n\nHere, we download the *Arabidopsis thaliana* reference genome and index it:\n\n```{bash filename=\"bash\"}\n#| eval: false\n# Index command here\n```\n\nAllright, let's finally run `STAR`: \n\n```{bash filename=\"bash\"}\n#| eval: false\n# run STAR here\n```\n\n### BAM and SAM files\n\n*TODO: explain BAM and SAM files here*\n\n### Inspecting the mapping on a genome browser\n\n## Counting: `featureCounts`\n\n## A note on the specific tools used here\n\nAs in many things in programming: there are many ways to reach the same goal. Here we have selected mapping, trimming and counting tools that we have available and have experience with, but there are many others that perform just as well. The following table highlights a few popular alternative options:\n\n| Task | Tool used here | Alternative tools |\n| ---- | -------------- | ----------------- |\n| Trimming | `Trimmomatic` | `cutadapt`, `fastp` |\n| Mapping | `STAR` | `HISAT2` |\n| Counting | `featureCounts` | `StringTie` |"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"03-mapping-reads.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"flatly","title":"From fastq files to alignments","code-annotations":"hover"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}